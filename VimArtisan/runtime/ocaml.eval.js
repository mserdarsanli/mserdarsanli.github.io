(function() {
var res = {};
res['lang-syntax'] = (function() {
var res = {};
res['lang'] = 'Rules for Lang: ocaml';
res['syntax-groups'] = {};
res['syntax-groups']['SpecialKey'] = SyntaxGroup.FromColor('SpecialKey', new TermColor(4), new TermColor(-1));
res['syntax-groups']['NonText'] = SyntaxGroup.FromColor('NonText', new TermColor(12), new TermColor(-1));
res['syntax-groups']['Directory'] = SyntaxGroup.FromColor('Directory', new TermColor(4), new TermColor(-1));
res['syntax-groups']['IncSearch'] = SyntaxGroup.FromColor('IncSearch', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ModeMsg'] = SyntaxGroup.FromColor('ModeMsg', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['LineNr'] = SyntaxGroup.FromColor('LineNr', new TermColor(130), new TermColor(-1));
res['syntax-groups']['CursorLineNr'] = SyntaxGroup.FromColor('CursorLineNr', new TermColor(130), new TermColor(-1));
res['syntax-groups']['StatusLineNC'] = SyntaxGroup.FromColor('StatusLineNC', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['VertSplit'] = SyntaxGroup.FromColor('VertSplit', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['Title'] = SyntaxGroup.FromColor('Title', new TermColor(5), new TermColor(-1));
res['syntax-groups']['VisualNOS'] = SyntaxGroup.FromColor('VisualNOS', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['WildMenu'] = SyntaxGroup.FromColor('WildMenu', new TermColor(0), new TermColor(11));
res['syntax-groups']['Folded'] = SyntaxGroup.FromColor('Folded', new TermColor(4), new TermColor(248));
res['syntax-groups']['FoldColumn'] = SyntaxGroup.FromColor('FoldColumn', new TermColor(4), new TermColor(248));
res['syntax-groups']['DiffAdd'] = SyntaxGroup.FromColor('DiffAdd', new TermColor(-1), new TermColor(81));
res['syntax-groups']['DiffChange'] = SyntaxGroup.FromColor('DiffChange', new TermColor(-1), new TermColor(225));
res['syntax-groups']['DiffDelete'] = SyntaxGroup.FromColor('DiffDelete', new TermColor(12), new TermColor(159));
res['syntax-groups']['DiffText'] = SyntaxGroup.FromColor('DiffText', new TermColor(-1), new TermColor(9));
res['syntax-groups']['SignColumn'] = SyntaxGroup.FromColor('SignColumn', new TermColor(4), new TermColor(248));
res['syntax-groups']['Conceal'] = SyntaxGroup.FromColor('Conceal', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['SpellBad'] = SyntaxGroup.FromColor('SpellBad', new TermColor(-1), new TermColor(224));
res['syntax-groups']['SpellCap'] = SyntaxGroup.FromColor('SpellCap', new TermColor(-1), new TermColor(81));
res['syntax-groups']['SpellRare'] = SyntaxGroup.FromColor('SpellRare', new TermColor(-1), new TermColor(225));
res['syntax-groups']['SpellLocal'] = SyntaxGroup.FromColor('SpellLocal', new TermColor(-1), new TermColor(14));
res['syntax-groups']['Pmenu'] = SyntaxGroup.FromColor('Pmenu', new TermColor(0), new TermColor(225));
res['syntax-groups']['PmenuSel'] = SyntaxGroup.FromColor('PmenuSel', new TermColor(0), new TermColor(7));
res['syntax-groups']['PmenuSbar'] = SyntaxGroup.FromColor('PmenuSbar', new TermColor(-1), new TermColor(248));
res['syntax-groups']['PmenuThumb'] = SyntaxGroup.FromColor('PmenuThumb', new TermColor(-1), new TermColor(0));
res['syntax-groups']['TabLine'] = SyntaxGroup.FromColor('TabLine', new TermColor(0), new TermColor(7));
res['syntax-groups']['TabLineSel'] = SyntaxGroup.FromColor('TabLineSel', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['TabLineFill'] = SyntaxGroup.FromColor('TabLineFill', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['CursorColumn'] = SyntaxGroup.FromColor('CursorColumn', new TermColor(-1), new TermColor(7));
res['syntax-groups']['CursorLine'] = SyntaxGroup.FromColor('CursorLine', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ColorColumn'] = SyntaxGroup.FromColor('ColorColumn', new TermColor(-1), new TermColor(224));
res['syntax-groups']['MatchParen'] = SyntaxGroup.FromColor('MatchParen', new TermColor(-1), new TermColor(14));
res['syntax-groups']['Underlined'] = SyntaxGroup.FromColor('Underlined', new TermColor(5), new TermColor(-1));
res['syntax-groups']['Ignore'] = SyntaxGroup.FromColor('Ignore', new TermColor(15), new TermColor(-1));
res['syntax-groups']['ocamlMethod'] = SyntaxGroup.FromLink('ocamlMethod', 'Include');
res['syntax-groups']['ocamlComment'] = SyntaxGroup.FromLink('ocamlComment', 'Comment');
res['syntax-groups']['ocamlScript'] = SyntaxGroup.FromLink('ocamlScript', 'Include');
res['syntax-groups']['ocamlLCIdentifier'] = SyntaxGroup.FromColor('ocamlLCIdentifier', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlKeyChar'] = SyntaxGroup.FromLink('ocamlKeyChar', 'Keyword');
res['syntax-groups']['ocamlBraceErr'] = SyntaxGroup.FromLink('ocamlBraceErr', 'Error');
res['syntax-groups']['ocamlBrackErr'] = SyntaxGroup.FromLink('ocamlBrackErr', 'Error');
res['syntax-groups']['ocamlParenErr'] = SyntaxGroup.FromLink('ocamlParenErr', 'Error');
res['syntax-groups']['ocamlArrErr'] = SyntaxGroup.FromLink('ocamlArrErr', 'Error');
res['syntax-groups']['ocamlCommentErr'] = SyntaxGroup.FromLink('ocamlCommentErr', 'Error');
res['syntax-groups']['ocamlCountErr'] = SyntaxGroup.FromLink('ocamlCountErr', 'Error');
res['syntax-groups']['ocamlDoErr'] = SyntaxGroup.FromLink('ocamlDoErr', 'Error');
res['syntax-groups']['ocamlDoneErr'] = SyntaxGroup.FromLink('ocamlDoneErr', 'Error');
res['syntax-groups']['ocamlThenErr'] = SyntaxGroup.FromLink('ocamlThenErr', 'Error');
res['syntax-groups']['ocamlEndErr'] = SyntaxGroup.FromLink('ocamlEndErr', 'Error');
res['syntax-groups']['ocamlTodo'] = SyntaxGroup.FromLink('ocamlTodo', 'Todo');
res['syntax-groups']['ocamlPreDef'] = SyntaxGroup.FromColor('ocamlPreDef', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlModParam'] = SyntaxGroup.FromColor('ocamlModParam', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlModParam1'] = SyntaxGroup.FromLink('ocamlModParam1', 'Include');
res['syntax-groups']['ocamlPreMPRestr'] = SyntaxGroup.FromColor('ocamlPreMPRestr', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlMPRestr'] = SyntaxGroup.FromColor('ocamlMPRestr', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlMPRestr1'] = SyntaxGroup.FromColor('ocamlMPRestr1', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlMPRestr2'] = SyntaxGroup.FromLink('ocamlMPRestr2', 'Keyword');
res['syntax-groups']['ocamlMPRestr3'] = SyntaxGroup.FromLink('ocamlMPRestr3', 'Include');
res['syntax-groups']['ocamlModRHS'] = SyntaxGroup.FromColor('ocamlModRHS', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlFuncWith'] = SyntaxGroup.FromColor('ocamlFuncWith', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlFuncStruct'] = SyntaxGroup.FromColor('ocamlFuncStruct', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlModTypeRestr'] = SyntaxGroup.FromLink('ocamlModTypeRestr', 'Include');
res['syntax-groups']['ocamlModTRWith'] = SyntaxGroup.FromColor('ocamlModTRWith', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlWith'] = SyntaxGroup.FromLink('ocamlWith', 'Include');
res['syntax-groups']['ocamlWithRest'] = SyntaxGroup.FromColor('ocamlWithRest', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlModType'] = SyntaxGroup.FromLink('ocamlModType', 'Include');
res['syntax-groups']['ocamlFullMod'] = SyntaxGroup.FromLink('ocamlFullMod', 'Include');
res['syntax-groups']['ocamlVal'] = SyntaxGroup.FromLink('ocamlVal', 'Keyword');
res['syntax-groups']['ocamlKeyword'] = SyntaxGroup.FromLink('ocamlKeyword', 'Keyword');
res['syntax-groups']['ocamlEncl'] = SyntaxGroup.FromLink('ocamlEncl', 'Keyword');
res['syntax-groups']['ocamlObject'] = SyntaxGroup.FromLink('ocamlObject', 'Include');
res['syntax-groups']['ocamlEnd'] = SyntaxGroup.FromColor('ocamlEnd', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlNone'] = SyntaxGroup.FromColor('ocamlNone', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlDo'] = SyntaxGroup.FromColor('ocamlDo', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlModule'] = SyntaxGroup.FromLink('ocamlModule', 'Include');
res['syntax-groups']['ocamlSig'] = SyntaxGroup.FromColor('ocamlSig', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlModSpec'] = SyntaxGroup.FromColor('ocamlModSpec', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlModPreRHS'] = SyntaxGroup.FromLink('ocamlModPreRHS', 'Keyword');
res['syntax-groups']['ocamlStruct'] = SyntaxGroup.FromColor('ocamlStruct', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlMTDef'] = SyntaxGroup.FromLink('ocamlMTDef', 'Include');
res['syntax-groups']['ocamlBoolean'] = SyntaxGroup.FromLink('ocamlBoolean', 'Boolean');
res['syntax-groups']['ocamlType'] = SyntaxGroup.FromLink('ocamlType', 'Type');
res['syntax-groups']['ocamlOperator'] = SyntaxGroup.FromLink('ocamlOperator', 'Keyword');
res['syntax-groups']['ocamlConstructor'] = SyntaxGroup.FromLink('ocamlConstructor', 'Constant');
res['syntax-groups']['ocamlModPath'] = SyntaxGroup.FromLink('ocamlModPath', 'Include');
res['syntax-groups']['ocamlCharacter'] = SyntaxGroup.FromLink('ocamlCharacter', 'Character');
res['syntax-groups']['ocamlCharErr'] = SyntaxGroup.FromLink('ocamlCharErr', 'Error');
res['syntax-groups']['ocamlString'] = SyntaxGroup.FromLink('ocamlString', 'String');
res['syntax-groups']['ocamlFunDef'] = SyntaxGroup.FromLink('ocamlFunDef', 'Keyword');
res['syntax-groups']['ocamlRefAssign'] = SyntaxGroup.FromLink('ocamlRefAssign', 'Keyword');
res['syntax-groups']['ocamlTopStop'] = SyntaxGroup.FromLink('ocamlTopStop', 'Keyword');
res['syntax-groups']['ocamlAnyVar'] = SyntaxGroup.FromLink('ocamlAnyVar', 'Keyword');
res['syntax-groups']['ocamlNumber'] = SyntaxGroup.FromLink('ocamlNumber', 'Number');
res['syntax-groups']['ocamlFloat'] = SyntaxGroup.FromLink('ocamlFloat', 'Float');
res['syntax-groups']['ocamlLabel'] = SyntaxGroup.FromLink('ocamlLabel', 'Identifier');
res['syntax-groups']['ocamlDoSync'] = SyntaxGroup.FromColor('ocamlDoSync', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlEndSync'] = SyntaxGroup.FromColor('ocamlEndSync', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlStructSync'] = SyntaxGroup.FromColor('ocamlStructSync', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlSigSync'] = SyntaxGroup.FromColor('ocamlSigSync', new TermColor(-1), new TermColor(-1));
res['syntax-groups']['ocamlErr'] = SyntaxGroup.FromLink('ocamlErr', 'Error');
return res;
} ())
;
res['snippets'] = [];
res['snippets'].push({
  'title': 'Find Missing Perm',
  'terminal-contents': '<vocaml-comment>(* insert x at all positions into li and return the list of results *)</vocaml-comment><v-normal>          </v-normal>\n<vocaml-keyword>let</vocaml-keyword><v-normal> </v-normal><vocaml-keyword>rec</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>insert</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-l-c-identifier>x</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-key-char>=</vocaml-key-char><v-normal> </v-normal><vocaml-keyword>function</vocaml-keyword><v-normal>                                                     </v-normal>\n<v-normal>  </v-normal><vocaml-key-char>|</vocaml-key-char><v-normal> </v-normal><vocaml-constructor>[]</vocaml-constructor><v-normal> </v-normal><vocaml-fun-def>-&gt;</vocaml-fun-def><v-normal> </v-normal><vocaml-keyword>[[</vocaml-keyword><vocaml-l-c-identifier>x</vocaml-l-c-identifier><vocaml-keyword>]]</vocaml-keyword><v-normal>                                                                 </v-normal>\n<v-normal>  </v-normal><vocaml-key-char>|</vocaml-key-char><v-normal> </v-normal><vocaml-l-c-identifier>a</vocaml-l-c-identifier><vocaml-operator>::</vocaml-operator><vocaml-l-c-identifier>m</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-keyword>as</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>li</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-fun-def>-&gt;</vocaml-fun-def><v-normal> </v-normal><vocaml-keyword>(</vocaml-keyword><vocaml-l-c-identifier>x</vocaml-l-c-identifier><vocaml-operator>::</vocaml-operator><vocaml-l-c-identifier>li</vocaml-l-c-identifier><vocaml-keyword>)</vocaml-keyword><v-normal> </v-normal><vocaml-operator>::</vocaml-operator><v-normal> </v-normal><vocaml-keyword>(</vocaml-keyword><vocaml-mod-path>List</vocaml-mod-path><v-normal>.</v-normal><vocaml-l-c-identifier>map</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-keyword>(fun</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>y</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-fun-def>-&gt;</vocaml-fun-def><v-normal> </v-normal><vocaml-l-c-identifier>a</vocaml-l-c-identifier><vocaml-operator>::</vocaml-operator><vocaml-l-c-identifier>y</vocaml-l-c-identifier><vocaml-keyword>)</vocaml-keyword><v-normal> </v-normal><vocaml-keyword>(</vocaml-keyword><vocaml-l-c-identifier>insert</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-l-c-identifier>x</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-l-c-identifier>m</vocaml-l-c-identifier><vocaml-keyword>))</vocaml-keyword><v-normal>            </v-normal>\n<v-normal>                                                                                </v-normal>\n<vocaml-comment>(* list of all permutations of li *)</vocaml-comment><v-normal>                                            </v-normal>\n<vocaml-keyword>let</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>permutations</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-l-c-identifier>li</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-key-char>=</vocaml-key-char><v-normal>                                                           </v-normal>\n<v-normal>  </v-normal><vocaml-mod-path>List</vocaml-mod-path><v-normal>.</v-normal><vocaml-l-c-identifier>fold_right</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-keyword>(fun</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>a</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-l-c-identifier>z</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-fun-def>-&gt;</vocaml-fun-def><v-normal> </v-normal><vocaml-mod-path>List</vocaml-mod-path><v-normal>.</v-normal><vocaml-l-c-identifier>concat</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-keyword>(</vocaml-keyword><vocaml-mod-path>List</vocaml-mod-path><v-normal>.</v-normal><vocaml-l-c-identifier>map</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-keyword>(</vocaml-keyword><vocaml-l-c-identifier>insert</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-l-c-identifier>a</vocaml-l-c-identifier><vocaml-keyword>)</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>z</vocaml-l-c-identifier><vocaml-keyword>))</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>li</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-keyword>[</vocaml-keyword><vocaml-constructor>[]</vocaml-constructor><vocaml-keyword>]</vocaml-keyword><v-normal>0m]   </v-normal>\n<v-normal>                                                                                </v-normal>\n<vocaml-comment>(* convert a string to a char list *)</vocaml-comment><v-normal>                                           </v-normal>\n<vocaml-keyword>let</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>chars_of_string</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-l-c-identifier>s</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-key-char>=</vocaml-key-char><v-normal>                                                         </v-normal>\n<v-normal>  </v-normal><vocaml-keyword>let</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>cl</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-key-char>=</vocaml-key-char><v-normal> </v-normal><vocaml-l-c-identifier>ref</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-constructor>[]</vocaml-constructor><v-normal> </v-normal><vocaml-keyword>in</vocaml-keyword><v-normal>                                                            </v-normal>\n<v-normal>  </v-normal><vocaml-mod-path>String</vocaml-mod-path><v-normal>.</v-normal><vocaml-l-c-identifier>iter</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-keyword>(fun</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>c</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-fun-def>-&gt;</vocaml-fun-def><v-normal> </v-normal><vocaml-l-c-identifier>cl</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-ref-assign>:=</vocaml-ref-assign><v-normal> </v-normal><vocaml-l-c-identifier>c</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-operator>::</vocaml-operator><v-normal> </v-normal><vocaml-key-char>!</vocaml-key-char><vocaml-l-c-identifier>cl</vocaml-l-c-identifier><vocaml-keyword>)</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>s</vocaml-l-c-identifier><vocaml-key-char>;</vocaml-key-char><v-normal>                                      </v-normal>\n<v-normal>  </v-normal><vocaml-keyword>(</vocaml-keyword><vocaml-mod-path>List</vocaml-mod-path><v-normal>.</v-normal><vocaml-l-c-identifier>rev</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-key-char>!</vocaml-key-char><vocaml-l-c-identifier>cl</vocaml-l-c-identifier><vocaml-keyword>)</vocaml-keyword><v-normal>                                                                </v-normal>\n<v-normal>                                                                                </v-normal>\n<vocaml-comment>(* convert a char list to a string *)</vocaml-comment><v-normal>                                           </v-normal>\n<vocaml-keyword>let</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>string_of_chars</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-l-c-identifier>cl</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-key-char>=</vocaml-key-char><v-normal>                                                        </v-normal>\n<v-normal>  </v-normal><vocaml-mod-path>String</vocaml-mod-path><v-normal>.</v-normal><vocaml-l-c-identifier>concat</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-string>&quot;&quot;</vocaml-string><v-normal> </v-normal><vocaml-keyword>(</vocaml-keyword><vocaml-mod-path>List</vocaml-mod-path><v-normal>.</v-normal><vocaml-l-c-identifier>map</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-keyword>(</vocaml-keyword><vocaml-mod-path>String</vocaml-mod-path><v-normal>.</v-normal><vocaml-l-c-identifier>make</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-float>1</vocaml-float><vocaml-keyword>)</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>cl</vocaml-l-c-identifier><vocaml-keyword>)</vocaml-keyword><v-normal>                                </v-normal>\n<v-normal>                                                                                </v-normal>\n<vocaml-keyword>let</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>deficient_perms</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-key-char>=</vocaml-key-char><v-normal> </v-normal><vocaml-keyword>[</vocaml-keyword><v-normal>                                                         </v-normal>\n<v-normal>  </v-normal><vocaml-string>&quot;ABCD&quot;</vocaml-string><vocaml-key-char>;</vocaml-key-char><vocaml-string>&quot;CABD&quot;</vocaml-string><vocaml-key-char>;</vocaml-key-char><vocaml-string>&quot;ACDB&quot;</vocaml-string><vocaml-key-char>;</vocaml-key-char><vocaml-string>&quot;DACB&quot;</vocaml-string><vocaml-key-char>;</vocaml-key-char><v-normal>                                                  </v-normal>\n<v-normal>  </v-normal><vocaml-string>&quot;BCDA&quot;</vocaml-string><vocaml-key-char>;</vocaml-key-char><vocaml-string>&quot;ACBD&quot;</vocaml-string><vocaml-key-char>;</vocaml-key-char><vocaml-string>&quot;ADCB&quot;</vocaml-string><vocaml-key-char>;</vocaml-key-char><vocaml-string>&quot;CDAB&quot;</vocaml-string><vocaml-key-char>;</vocaml-key-char><v-normal>                                                  </v-normal>\n<v-normal>  </v-normal><vocaml-string>&quot;DABC&quot;</vocaml-string><vocaml-key-char>;</vocaml-key-char><vocaml-string>&quot;BCAD&quot;</vocaml-string><vocaml-key-char>;</vocaml-key-char><vocaml-string>&quot;CADB&quot;</vocaml-string><vocaml-key-char>;</vocaml-key-char><vocaml-string>&quot;CDBA&quot;</vocaml-string><vocaml-key-char>;</vocaml-key-char><v-normal>                                                  </v-normal>\n<v-normal>                                                                                </v-normal>\n'
});
res['snippets'].push({
  'title': 'File Input/Output',
  'terminal-contents': '<vocaml-keyword>let</vocaml-keyword><v-normal> </v-normal><vocaml-constructor>()</vocaml-constructor><v-normal> </v-normal><vocaml-key-char>=</vocaml-key-char><v-normal>                                                                        </v-normal>\n<v-normal>  </v-normal><vocaml-keyword>let</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>ic</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-key-char>=</vocaml-key-char><v-normal> </v-normal><vocaml-l-c-identifier>open_in</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-string>&quot;input.txt&quot;</vocaml-string><v-normal> </v-normal><vocaml-keyword>in</vocaml-keyword><v-normal>                                               </v-normal>\n<v-normal>  </v-normal><vocaml-keyword>let</vocaml-keyword><v-normal> </v-normal><vocaml-l-c-identifier>oc</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-key-char>=</vocaml-key-char><v-normal> </v-normal><vocaml-l-c-identifier>open_out</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-string>&quot;output.txt&quot;</vocaml-string><v-normal> </v-normal><vocaml-keyword>in</vocaml-keyword><v-normal>                                             </v-normal>\n<v-normal>  </v-normal><vocaml-keyword>try</vocaml-keyword><v-normal>                                                                           </v-normal>\n<v-normal>    </v-normal><vocaml-keyword>while</vocaml-keyword><v-normal> </v-normal><vocaml-boolean>true</vocaml-boolean><v-normal> </v-normal><vocaml-keyword>do</vocaml-keyword><v-normal>                                                               </v-normal>\n<vocaml-do>      </vocaml-do><vocaml-keyword>let</vocaml-keyword><vocaml-do> </vocaml-do><vocaml-l-c-identifier>s</vocaml-l-c-identifier><vocaml-do> </vocaml-do><vocaml-key-char>=</vocaml-key-char><vocaml-do> </vocaml-do><vocaml-l-c-identifier>input_line</vocaml-l-c-identifier><vocaml-do> </vocaml-do><vocaml-l-c-identifier>ic</vocaml-l-c-identifier><vocaml-do> </vocaml-do><vocaml-keyword>in</vocaml-keyword><v-normal>                                                  </v-normal>\n<vocaml-do>      </vocaml-do><vocaml-l-c-identifier>output_string</vocaml-l-c-identifier><vocaml-do> </vocaml-do><vocaml-l-c-identifier>oc</vocaml-l-c-identifier><vocaml-do> </vocaml-do><vocaml-l-c-identifier>s</vocaml-l-c-identifier><vocaml-key-char>;</vocaml-key-char><v-normal>                                                       </v-normal>\n<vocaml-do>      </vocaml-do><vocaml-l-c-identifier>output_char</vocaml-l-c-identifier><vocaml-do> </vocaml-do><vocaml-l-c-identifier>oc</vocaml-l-c-identifier><vocaml-do> </vocaml-do><vocaml-character>&apos;&#92;n&apos;</vocaml-character><vocaml-key-char>;</vocaml-key-char><v-normal>                                                      </v-normal>\n<vocaml-do>    </vocaml-do><vocaml-keyword>done</vocaml-keyword><v-normal>                                                                        </v-normal>\n<v-normal>  </v-normal><vocaml-keyword>with</vocaml-keyword><v-normal> </v-normal><vocaml-constructor>End_of_file</vocaml-constructor><v-normal> </v-normal><vocaml-fun-def>-&gt;</vocaml-fun-def><v-normal>                                                           </v-normal>\n<v-normal>    </v-normal><vocaml-l-c-identifier>close_in</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-l-c-identifier>ic</vocaml-l-c-identifier><vocaml-key-char>;</vocaml-key-char><v-normal>                                                                </v-normal>\n<v-normal>    </v-normal><vocaml-l-c-identifier>close_out</vocaml-l-c-identifier><v-normal> </v-normal><vocaml-l-c-identifier>oc</vocaml-l-c-identifier><vocaml-key-char>;</vocaml-key-char><v-normal>                                                               </v-normal>\n<vocaml-key-char>;;</vocaml-key-char><v-normal>                                                                              </v-normal>\n<v-non-text>~                                                                               </v-non-text>\n<v-non-text>~                                                                               </v-non-text>\n<v-non-text>~                                                                               </v-non-text>\n<v-non-text>~                                                                               </v-non-text>\n<v-non-text>~                                                                               </v-non-text>\n<v-non-text>~                                                                               </v-non-text>\n<v-non-text>~                                                                               </v-non-text>\n<v-non-text>~                                                                               </v-non-text>\n<v-non-text>~                                                                               </v-non-text>\n<v-non-text>~                                                                               </v-non-text>\n<v-normal>                                                                                </v-normal>\n'
});
return res;
}())